This is a program to create a graph which represents connections between rides as a theme park. The class used for the graph allows the programmer to insert vertexes or connections which are edges. they can both contain data of any kind. To do this templates are used to effectively paste in data types. Instead of an array to hold all of the vertexes I have a tree which is ordered by key. That way there can't be the mistake of creating the same vertex twice. The vertexes stored in the tree have head pointers which point to a Linked list of edges. Each of these edges is also stored in a tree, this is for quick deletion of all the edge instances. The edges have an adjacent pointer that points to the vertex the initial vertex is connected to, and a next pointer to point to another edge which would contain another connection to another vertex.

The graph was great for this program. It was an interesting problem to see how there are even more abstract data types and ways of arranging and organizing data. The way that data can be connected seems to me like it requires a lot more memory to make graphs than other data structures because of their need to define the other connections. However it is a very powerful concept that makes route finding really easy.

I think that the only way a different data structure might have worked better is if it was a graph implemented better. I don't know how it would work but I'm sure it would involve more trees.

The way I designed the graph was more efficient then using an array for the vertices because I can use the binary search of the tree to get the the vertex fast. Also the recursion used to create the path array was challenging but also a fast way of looking down each path for the destination.

What was not efficient was my use of the tree as a way of seeing where I had been to in the path search. This was a waste of memory but I didn't have time to optimize that. Also I know the adjacency was supposed to be done with a linked list but it would have been faster to use a tree with the keys being the index in the list. That would have made finding the index in the adjacent list need recursion but the way I did it it could have just as easily been done with a loop.

If I had more time I would reduce the amount of memory that I am using I know I have a lot of trees that are consuming memory and I need to have some of them specialized. By that I mean the tree I used has a value item and a key but a lot of where I used them it would have been better just to have the key because as in the  have I been to this vertex example I didn't need to store any data.

