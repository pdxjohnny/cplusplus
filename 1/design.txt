/*
	Author: John Andersen
	Date: 01/15/2015
	Description: Design document of Homework 1
*/

The linked list of arrays was interesting because I didn't plan it in to start with and it ended up taking a lot of time to create and adapt to it. Because the data needed to be sorted I created dictionary abstractions for the arrays and the linked list of those arrays. because they need to be sorted it pretty much defeats the purpose and speed of using arrays because I have to shift the data around to sort every time something in inserted. In addition I have to make sure the key is in the right array and sorry the keys within all of the array making sure that the first array would have a and the last would have z. This requires me to look in all of them and sort all of them and it ends up being I think I haven't had time to count, a lot more operations than shifting around my linked list. A linked list would have been better because of all the sorting and the fact that I need to use pointers to my object classes because copying them over by value creates errors sometimes. Its not a very efficient design but I was going for ease of use for the client developer because if no one can use it they won't care if its 1/1000 of a second faster or not. The major inefficiency was the sorting of the arrays as well as I left my tail pointers in because I haven't taken them out sense the first time I wrote the doubly linked list. I don't think I change anything if I had more time. I would just use the linked list if I could do it the way I wanted because of the slowness to the array sorting rather than how quick it is to keep the linked list sorted. I try to write pretty modular code. The use of templates really helps that because then you can use the classes with many different data types. For example I have the pointer to a list element of type dict_array of type data_type in dict_dict_array. I really like templates because I find my self writing the same thing over and over again if I don't use them. I know that we are not supposed to include cpp files but those are my implementations and data_type gets changed to what ever data<type> I put in in my other files at compile time. The hardest part of this for me was keeping track of where my double frees were happening because there are five layers I'm pretty sure, of abstraction starting with list_el through user and they all are doing various things to the data being stored in them. My goal is always to have the errors high up that chain so in user or object, because the lower levels should always function the same way. In fact ideally I would be able to switch out the dict which is a linked list, with the dict_dict_array and have the program run the exact same way. The list of arrays was a problem because of the need to take one out when there is another whose key ranks higher and then finding a spot for the old one down the line of the list in another array. I just used recursion for this because I figured I already have a method for inserting at the right spot I might as well use it. So I would get a pointer to the one I just took out and set the value of the new space to the value of the old one and to do this I was dereferencing the pointers. ie *to = *from. This didn't work when I needed to set the objects to each other / sort them. Which is why I had to switch to pointers to objects.

I ended up not switching to pointers because I made it work. its not perfect though.